[{"id":"https:\/\/sandrokeil.github.io\/interop-config\/getting-started\/overview.html#1-1","title":"1.1. Overview","content":" You want to configure your factories?  You want to reduce your factory boilerplate code?  You want to check automatically for mandatory options or merge default options?  You want to have a valid config structure?  You want to generate your configuration files from factory classes?  This library comes to the rescue!  intop-config provides interfaces and a concrete implementation to create instances depending on configuration via factory classes and ensures a valid config structure. It can also be used to auto discover factories and to create configuration files. Well tested. Besides unit test and continuous integration\/inspection this solution is also ready for production use. Framework agnostic This PHP library does not depends on any framework but you can use it with your favourite framework. Every change is tracked. Want to know whats new? Take a look at the changelog section. Listen to your ideas. Have a great idea? Bring your tested pull request or open a new issue. See contributing section. You should have coding conventions and you should have config conventions. If not, you should think about that. interop-config is universally applicable! See further documentation for more details."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/getting-started\/overview.html#1-1-1","title":"1.1.1. Installation","content":"Installation of this library uses Composer. For Composer documentation, please refer to getcomposer.org.Put the following into your composer.json or run composer require sandrokeil\/interop-config.{ \"require\": { \"sandrokeil\/interop-config\": \"^1.0\" } } It is recommended to use container-interop to retrieve the configuration in your factories."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/getting-started\/overview.html#1-1-2","title":"1.1.2. Config Structure","content":" The following example is a common practice for libraries. You are free to use another config structure. See examples. The config keys should have the following structure vendor.package.container_id. The container_id is optional and is only necessary if you have different instances of the same class e.g. database connection.A common configuration looks like that:\/\/ interop config example return [ \/\/ vendor name 'doctrine' =&gt; [ \/\/ package name 'connection' =&gt; [ \/\/ container id 'orm_default' =&gt; [ \/\/ mandatory options 'driverClass' =&gt; 'Doctrine\\DBAL\\Driver\\PDOMySql\\Driver', 'params' =&gt; [ 'host' =&gt; 'localhost', 'port' =&gt; '3306', 'user' =&gt; 'username', 'password' =&gt; 'password', 'dbname' =&gt; 'database', ], ], ], ], ]; So doctrine is the vendor, connection is the package and orm_default is the container id. After that the specified instance options follow. The following example uses ConfigurationTrait which implements the logic to retrieve the options from a configuration. RequiresConfigId interface ensures support for more than one instance. Note that the configuration above is injected as $config in options() and container-interop is used to retrieve the application configuration. use Interop\\Config\\ConfigurationTrait; use Interop\\Config\\RequiresConfigId; use Interop\\Config\\RequiresMandatoryOptions; use Interop\\Container\\ContainerInterface; class MyDBALConnectionFactory implements RequiresConfigId, RequiresMandatoryOptions { use ConfigurationTrait; public function __invoke(ContainerInterface $container) { \/\/ get options for doctrine.connection.orm_default $options = $this-&gt;options($container-&gt;get('config'), 'orm_default'); \/\/ mandatory options check is automatically done by RequiresMandatoryOptions $driverClass = $options['driverClass']; $params = $options['params']; \/\/ create your instance and set options return $instance; } \/** * Is used to retrieve options from the configuration array ['doctrine' =&gt; ['connection' =&gt; []]]. * * @return [] *\/ public function dimensions() { return ['doctrine', 'connection']; } \/** * Returns a list of mandatory options which must be available * * @return string[] List with mandatory options *\/ public function mandatoryOptions() { return ['params' =&gt; ['user', 'password', 'dbname']]; } } "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/getting-started\/quick-Start.html#1-2","title":"1.2. Quick Start","content":"Typically you will have a factory which creates a concrete instance depending on some options (dependencies)."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/getting-started\/quick-Start.html#1-2-1","title":"1.2.1. RequiresConfig interface","content":"Let's say My factory requires a configuration so you will implement the RequiresConfig interface.use Interop\\Config\\RequiresConfig; class MyAwesomeFactory implements RequiresConfig { public function dimensions() { return ['vendor-package']; } public function canRetrieveOptions($config) { \/\/ custom implementation depending on specifications } public function options($config) { \/\/ custom implementation depending on specifications } } "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/getting-started\/quick-Start.html#1-2-1-1","title":"1.2.1.1. Need configuration per container id","content":"If you support more than one instance with different configuration then you simply use the RequiresConfigId interface. Don't use the dimensions() method for container id configuration use Interop\\Config\\RequiresConfigId; class MyAwesomeFactory implements RequiresConfigId { public function dimensions() { return ['vendor-package']; } public function canRetrieveOptions($config, $configId = null) { \/\/ custom implementation depending on specifications } public function options($config, $configId = null) { \/\/ custom implementation depending on specifications } } Ok you have now a factory which says that the factory supports a configuration and you have a PHP file which contains the configuration as a PHP array, but how is the configuration used?Depending on the implemented interface RequiresConfigId above our configuration PHP file looks like that:\/\/ interop config example return [ \/\/ vendor\/package name 'vendor-package' =&gt; [ \/\/ container id 'container-id' =&gt; [ \/\/ some options ... ], ], ]; As you can see that you have to implement the functionality of canRetrieveOptions() and options() method. Good news, this is not necessary. See ConfigurationTrait."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/getting-started\/quick-Start.html#1-2-2","title":"1.2.2. ConfigurationTrait","content":"The ConfigurationTrait is a concrete implementation of the RequiresConfig interface and has full support of ProvidesDefaultOptions, RequiresMandatoryOptions and RequiresConfigIdinterfaces. It's a PHP Trait so you can extend your factory from a class.Your factory looks now like that:use Interop\\Config\\RequiresConfigId; use Interop\\Config\\ConfigurationTrait; class MyAwesomeFactory implements RequiresConfigId { use ConfigurationTrait; public function dimensions() { return ['vendor-package']; } } Now you have all the ingredients to create multiple different instances depending on configuration."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/getting-started\/quick-Start.html#1-2-3","title":"1.2.3. Create an instance","content":"Factories are often implemented as a callable. This means that your factory instance can be called like a function. You can also use a create method or something else.The factory gets a ContainerInterface (Container PSR) provided to retrieve the configuration. Note that the configuration above is injected as $config in options() and container-interop is used to retrieve the application configuration. use Interop\\Config\\RequiresConfigId; use Interop\\Config\\ConfigurationTrait; use Interop\\Container\\ContainerInterface; class MyAwesomeFactory implements RequiresConfigId { use ConfigurationTrait; public function dimensions() { return ['vendor-package']; } public function __invoke(ContainerInterface $container) { \/\/ get options for vendor-package.container-id \/\/ method options() is implemented in ConfigurationTrait $options = $this-&gt;options($container-&gt;get('config'), 'orm_default'); return new Awesome($options); } } The ConfigurationTrait does the job to check and retrieve options depending on implemented interfaces. Nice, but what is if I have mandatory options? See RequiresMandatoryOptions interface."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/getting-started\/quick-Start.html#1-2-4","title":"1.2.4. RequiresMandatoryOptions interface","content":"The RequiresConfig::options() interface specification says that it MUST support mandatory options check. Let's say that we need params for a db connection. Our config should looks like that:\/\/ interop config example return [ \/\/ vendor\/package name 'vendor-package' =&gt; [ \/\/ container id 'container-id' =&gt; [ 'params' =&gt; [ 'user' =&gt; 'username', 'password' =&gt; 'password', 'dbname' =&gt; 'database', ], ], ], ]; Remember our factory sentence. My factory requires a configuration and requires a container id along with mandatory options. The ConfigurationTrait ensures that these options are available, otherwise an exception is thrown. This is great, because the developer gets an exact exception message with what is wrong. This is useful for developers who use your factory the first time.use Interop\\Config\\RequiresConfigId; use Interop\\Config\\RequiresMandatoryOptions; use Interop\\Config\\ConfigurationTrait; use Interop\\Container\\ContainerInterface; class MyAwesomeFactory implements RequiresConfigId, RequiresMandatoryOptions { use ConfigurationTrait; public function dimensions() { return ['vendor-package']; } public function mandatoryOptions() { return ['params' =&gt; ['user', 'password', 'dbname']]; } public function __invoke(ContainerInterface $container) { \/\/ get options for vendor-package.container-id \/\/ method options() is implemented in ConfigurationTrait \/\/ an exception is raised when a mandatory option is missing $options = $this-&gt;options($container-&gt;get('config'), 'container-id'); return new Awesome($options); } } Hey, the database port and host is missing. That's right, but the default value of the port is 3306 and the host is localhost. It makes no sense to set it in the configuration. So I make the database port\/host not configurable? No, you use the ProvidesDefaultOptions interface."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/getting-started\/quick-Start.html#1-2-5","title":"1.2.5. ProvidesDefaultOptions interface","content":"The ProvidesDefaultOptions interface defines default options for your instance. These options are merged with the provided options.Remember: My factory requires configuration, requires a container id along with mandatory options and it provides default options.use Interop\\Config\\RequiresConfigId; use Interop\\Config\\RequiresMandatoryOptions; use Interop\\Config\\ProvidesDefaultOptions; use Interop\\Config\\ConfigurationTrait; use Interop\\Container\\ContainerInterface; class MyAwesomeFactory implements RequiresConfigId, RequiresMandatoryOptions, ProvidesDefaultOptions { use ConfigurationTrait; public function dimensions() { return ['vendor-package']; } public function mandatoryOptions() { return ['params' =&gt; ['user', 'password', 'dbname']]; } public function defaultOptions() { return [ 'params' =&gt; [ 'host' =&gt; 'localhost', 'port' =&gt; '3306', ], ]; } public function __invoke(ContainerInterface $container) { \/\/ get options for vendor-package.container-id \/\/ method options() is implemented in ConfigurationTrait \/\/ an exception is raised when a mandatory option is missing \/\/ if host\/port is missing, default options will be used $options = $this-&gt;options($container-&gt;get('config'), 'container-id'); return new Awesome($options); } } Now you have a bullet proof factory class which throws meaningful exceptions if something goes wrong. This is cool, but I don't want to use exceptions. No problem, see next."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/getting-started\/quick-Start.html#1-2-6","title":"1.2.6. Avoid exceptions","content":"The RequiresConfig interface provides a method canRetrieveOptions(). This method checks if options are available depending on implemented interfaces and checks that the retrieved options are an array or have implemented \\ArrayAccess.You can call this function and if it returns false, you can use the default options.use Interop\\Config\\RequiresConfigId; use Interop\\Config\\RequiresMandatoryOptions; use Interop\\Config\\ProvidesDefaultOptions; use Interop\\Config\\ConfigurationTrait; use Interop\\Container\\ContainerInterface; class MyAwesomeFactory implements RequiresConfigId, RequiresMandatoryOptions, ProvidesDefaultOptions { use ConfigurationTrait; \/\/ other functions see above public function __invoke(ContainerInterface $container) { $config = $container-&gt;get('config'); $options = []; if ($this-&gt;canRetrieveOptions($config, 'container-id')) { \/\/ get options for vendor-package.container-id \/\/ method options() is implemented in ConfigurationTrait \/\/ if host\/port is missing, default options will be used $options = $this-&gt;options($config, 'container-id'); } elseif ($this instanceof ProvidesDefaultOptions) { $options = $this-&gt;defaultOptions(); } return new Awesome($options); } } Nice, is there a one-liner? Of course. You can use the optionsWithFallback() method. This function is not a part of the specification but is implemented in ConfigurationTrait to reduce some boilerplate code.use Interop\\Config\\RequiresConfigId; use Interop\\Config\\RequiresMandatoryOptions; use Interop\\Config\\ProvidesDefaultOptions; use Interop\\Config\\ConfigurationTrait; use Interop\\Container\\ContainerInterface; class MyAwesomeFactory implements RequiresConfigId, RequiresMandatoryOptions, ProvidesDefaultOptions { use ConfigurationTrait; \/\/ other functions see above public function __invoke(ContainerInterface $container) { \/\/ get options for vendor-package.container-id \/\/ method options() is implemented in ConfigurationTrait \/\/ if configuration is not available, default options will be used $options = $this-&gt;optionsWithFallback($container-&gt;get('config'), 'container-id'); return new Awesome($options); } } Using optionsWithFallback() method and the RequiresMandatoryOptions is ambiguous or? Yes, so it's up to you to implement the interfaces in a sense order.Take a look at the examples section for more use cases. interop-config is universally applicable."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/api.html#2-1","title":"2.1. API","content":"This file describes the classes of this package. All interfaces can be combined. Don't panic, the interfaces are quite easy and the ConfigurationTrait, which is a concrete implementation, has full support of those interfaces. You need only one interface called RequiresConfig to start and then you can implement the others if they are needed. RequiresConfig Interface RequiresConfigId Interface RequiresMandatoryOptions Interface ProvidesDefaultOptions Interface "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/api.html#2-1-1","title":"2.1.1. RequiresConfig Interface","content":"The RequiresConfig interface exposes three methods: dimensions, canRetrieveOptions and options."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/api.html#2-1-1-1","title":"2.1.1.1. dimensions()","content":" public function dimensions() : [] The dimensions method has no parameters and MUST return an array. The values (used as key names) of the array are used as the depth of the configuration to retrieve options. Two values means a configuration depth of two. An empty array is valid."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/api.html#2-1-1-2","title":"2.1.1.2. canRetrieveOptions()","content":" public function canRetrieveOptions($config) : bool Checks if options are available depending on provided dimensions and checks that the retrieved options are an array or have implemented \\ArrayAccess."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/api.html#2-1-1-3","title":"2.1.1.3. options()","content":" public function options($config) : [] The options method takes one mandatory parameter: a configuration array. It MUST be an array or an object which implements the ArrayAccess interface. A call to options returns the configuration depending on provided dimensions of the class or throws an exception if the parameter is invalid or if the configuration is missing or if a mandatory option is missing.If the ProvidesDefaultOptions interface is implemented, these options MUST be overridden by the provided config."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/api.html#2-1-1-3-1","title":"2.1.1.3.1. Exceptions","content":"Exceptions directly thrown by the options method MUST implement the Interop\\Config\\Exception\\ExceptionInterface.If the configuration parameter is not an array or not an object which implements the ArrayAccess interface the method SHOULD throw a Interop\\Config\\Exception\\InvalidArgumentException.If a key which is returned from dimensions is not set under the previous dimensions key in the configuration parameter, the method SHOULD throw a Interop\\Config\\Exception\\OptionNotFoundException.If a value from the configuration based on dimensions is not an array or an object which has \\ArrayAccess implemented, the method SHOULD throw a Interop\\Config\\Exception\\UnexpectedValueException.If the class implements the RequiresMandatoryOptions interface and if a mandatory option from mandatoryOptions is not set in the options array which was retrieved from the configuration parameter before, the method SHOULD throw a Interop\\Config\\Exception\\MandatoryOptionNotFoundException.If the retrieved options are not of type array or \\ArrayAccess the method SHOULD throw a Interop\\Config\\Exception\\UnexpectedValueException."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/api.html#2-1-2","title":"2.1.2. RequiresMandatoryOptions Interface","content":"The RequiresMandatoryOptions interface exposes one method: mandatoryOptions"},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/api.html#2-1-2-1","title":"2.1.2.1. mandatoryOptions()","content":" public function mandatoryOptions() : string[] The mandatoryOptions method has no parameters and MUST return an array of strings which represents the list of mandatory options. This array can have a multiple depth."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/api.html#2-1-3","title":"2.1.3. ProvidesDefaultOptions Interface","content":"The DefaultOptions interface exposes one method: defaultOptions"},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/api.html#2-1-3-1","title":"2.1.3.1. defaultOptions()","content":" public function defaultOptions() : [] The defaultOptions method has no parameters and MUST return an key-value array where the key is the option name and the value is the default value for this option. This array can have a multiple depth. The return value MUST be compatible with the PHP function array_replace_recursive."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/api.html#2-1-4","title":"2.1.4. RequiresConfigId","content":"The RequiresConfigId is only a marker interface and has no methods. It marks the factory that multiple instances are supported. The ConfigurationTrait has an optional parameter $configId implemented for the methods of RequiresConfig. So it is full supported."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/api.html#2-1-5","title":"2.1.5. ConfigurationTrait","content":"The ConfigurationTrait implements the functions of RequiresConfig interface and has support for ProvidesDefaultOptions, RequiresMandatoryOptions and RequiresConfigId interfaces if the the class has they implemented.Additional it has one more method optionsWithFallback to reduce boilerplate code."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/api.html#2-1-5-1","title":"2.1.5.1. optionsWithFallback()","content":" public function optionsWithFallback($config) : [] Checks if options can be retrieved from config and if not, default options (ProvidesDefaultOptions interface) or an empty array will be returned."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/examples.html#2-2","title":"2.2. Examples","content":"This files contains examples for each interface. The factory class uses the ConfigurationTrait to retrieve options from a configuration and optional to perform a mandatory option check or merge default options. There is also an example for a independent config structure of the Zend Expressive TwigRendererFactory."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/examples.html#2-2-1","title":"2.2.1. Use a vendor.package.id config structure","content":"Let's assume we have the following module configuration:\/\/ interop config example return [ \/\/ vendor name 'doctrine' =&gt; [ \/\/ package name 'connection' =&gt; [ \/\/ container id 'orm_default' =&gt; [ \/\/ mandatory params 'driverClass' =&gt; 'Doctrine\\DBAL\\Driver\\PDOMySql\\Driver', 'params' =&gt; [ 'host' =&gt; 'localhost', 'port' =&gt; '3306', 'user' =&gt; 'username', 'password' =&gt; 'password', 'dbname' =&gt; 'database', ], ], ], ], ];  Note that the configuration above is injected as $config in options() "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/examples.html#2-2-1-1","title":"2.2.1.1. Retrieving options","content":"Then you have easily access to the orm_default options in your method with ConfigurationTrait.use Interop\\Config\\ConfigurationTrait; use Interop\\Config\\RequiresConfigId; class MyDBALConnectionFactory implements RequiresConfigId { use ConfigurationTrait; public function __invoke(ContainerInterface $container) { \/\/ get options for doctrine.connection.orm_default $options = $this-&gt;options($container-&gt;get('config'), 'orm_default'); \/\/ check if mandatory options are available or use \\Interop\\Config\\RequiresMandatoryOptions, see below if (empty($options['driverClass'])) { throw new Exception\\RuntimeException( sprintf( 'Driver class was not set for configuration %s.%s.%s', 'doctrine', 'connection', 'orm_default' ) ); } if (empty($options['params'])) { throw new Exception\\RuntimeException( sprintf( 'Params was not set for configuration %s.%s.%s', 'doctrine', 'connection', 'orm_default' ) ); } $driverClass = $options['driverClass']; $params = $options['params']; \/\/ create your instance and set options return $instance; } \/** * Is used to retrieve options from the configuration array ['doctrine' =&gt; ['connection' =&gt; [...]]]. * * @return [] *\/ public function dimensions() { return ['doctrine', 'connection']; } } "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/examples.html#2-2-1-2","title":"2.2.1.2. Mandatory options check","content":"You can also check for mandatory options automatically with MandatoryOptionsInterface. Now we want also check that option driverClass and params are available. So we also implement in the example above the interface RequiresMandatoryOptions. If one of these options is missing, an exception is raised.use Interop\\Config\\ConfigurationTrait; use Interop\\Config\\RequiresMandatoryOptions; use Interop\\Config\\RequiresConfigId; class MyDBALConnectionFactory implements RequiresConfigId, RequiresMandatoryOptions { use ConfigurationTrait; public function __invoke(ContainerInterface $container) { \/\/ get options for doctrine.connection.orm_default $options = $this-&gt;options($container-&gt;get('config'), 'orm_default'); \/\/ mandatory options check is automatically done by RequiresMandatoryOptions $driverClass = $options['driverClass']; $params = $options['params']; \/\/ create your instance and set options return $instance; } \/** * Returns a list of mandatory options which must be available * * @return string[] List with mandatory options *\/ public function mandatoryOptions() { return [ 'driverClass', 'params', ]; } \/** * Is used to retrieve options from the configuration array ['doctrine' =&gt; ['connection' =&gt; [...]]]. * * @return [] *\/ public function dimensions() { return ['doctrine', 'connection']; } } "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/examples.html#2-2-1-3","title":"2.2.1.3. Default options","content":"Use the ProvidesDefaultOptions interface if you have default options. These options are merged with the provided options in \\Interop\\Config\\RequiresConfig::options(). Let's look at this example from DoctrineORMModule. All the options under the key orm_crawler are optional, but it's not visible in the factory.return [ 'doctrine' =&gt; [ 'configuration' =&gt; [ 'orm_crawler' =&gt; [ 'metadata_cache' =&gt; 'array', 'query_cache' =&gt; 'array', 'result_cache' =&gt; 'array', 'hydration_cache' =&gt; 'array', ], ], ], ]; use Interop\\Config\\ConfigurationTrait; use Interop\\Config\\ProvidesDefaultOptions; use Interop\\Config\\RequiresConfigId; class ConfigurationFactory implements RequiresConfigId, ProvidesDefaultOptions { use ConfigurationTrait; public function __invoke(ContainerInterface $container) { \/\/ get options for doctrine.configuration.orm_crawler $options = $this-&gt;options($container-&gt;get('config'), 'orm_crawler'); # these keys are always available now $options['metadata_cache']; $options['query_cache']; $options['result_cache']; $options['hydration_cache']; \/\/ create your instance and set options return $instance; } \/** * Returns a list of default options, which are merged in \\Interop\\Config\\RequiresConfig::options * * @return string[] List with default options and values *\/ public function defaultOptions() { return [ 'metadata_cache' =&gt; 'array', 'query_cache' =&gt; 'array', 'result_cache' =&gt; 'array', 'hydration_cache' =&gt; 'array', ]; } \/** * Is used to retrieve options from the configuration array * ['doctrine' =&gt; ['configuration' =&gt; []]]. * * @return [] *\/ public function dimensions() { return ['doctrine', 'configuration']; } } "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/examples.html#2-2-2","title":"2.2.2. Use arbitrary configuration structure","content":"Whatever configuration structure you use, interop-config can handle it. You can use a three-dimensional array with vendor.package.id like the examples above or you don't care of it and organize your configuration by behavior or nature (db, cache, ... or sale, admin).The following example demonstrates how to replace the Zend Expressive TwigRendererFactory. The factory uses optionally the following config structure:return [ 'debug' =&gt; true, 'templates' =&gt; [ 'cache_dir' =&gt; 'path to cached templates', 'assets_url' =&gt; 'base URL for assets', 'assets_version' =&gt; 'base version for assets', 'extension' =&gt; 'file extension used by templates; defaults to html.twig', 'paths' =&gt; [ \/\/ namespace \/ path pairs \/\/ \/\/ Numeric namespaces imply the default\/main namespace. Paths may be \/\/ strings or arrays of string paths to associate with the namespace. ], ], 'twig' =&gt; [ 'cache_dir' =&gt; 'path to cached templates', 'assets_url' =&gt; 'base URL for assets', 'assets_version' =&gt; 'base version for assets', 'extensions' =&gt; [ \/\/ extension service names or instances ], ], ]; You can see that the factory uses different keys (debug, templates, twig) of the config array on the same level. This configuration is maybe used by other factories too like the debug setting. interop-config reduces the checks in the factory and gives the user the possibility to find out the config structure. More than that, it is possible to create the configuration file from the factory.namespace Zend\\Expressive\\Twig; use Interop\\Container\\ContainerInterface; use Twig_Environment as TwigEnvironment; use Twig_Extension_Debug as TwigExtensionDebug; use Twig_ExtensionInterface; use Twig_Loader_Filesystem as TwigLoader; use Zend\\Expressive\\Router\\RouterInterface; \/\/ interop-config use Interop\\Config\\ConfigurationTrait; use Interop\\Config\\RequiresConfig; use Interop\\Config\\ProvidesDefaultOptions; class TwigRendererFactory implements RequiresConfig, ProvidesDefaultOptions { use ConfigurationTrait; \/** * Uses root config to retrieve several options * * @return array *\/ public function dimensions() { return []; } \/** * This is the whole config structure with default settings for this factory *\/ public function defaultOptions() { return [ 'debug' =&gt; false, 'templates' =&gt; [ 'extension' =&gt; 'html.twig', 'paths' =&gt; [], ], 'twig' =&gt; [ 'cache_dir' =&gt; false, 'assets_url' =&gt; '', 'assets_version' =&gt; '', 'extensions' =&gt; [], ], ]; } \/** * @param ContainerInterface $container * @return TwigRenderer *\/ public function __invoke(ContainerInterface $container) { $config = $container-&gt;has('config') ? $container-&gt;get('config') : []; \/\/ no OptionNotFoundException is thrown from ConfigurationTrait, because there are no config dimensions $config = $this-&gt;options($config); $debug = (bool) $config['debug']; \/\/ Create the engine instance $loader = new TwigLoader(); $environment = new TwigEnvironment($loader, [ 'cache' =&gt; $debug ? false : $config['twig']['cache_dir'], 'debug' =&gt; $debug, 'strict_variables' =&gt; $debug, 'auto_reload' =&gt; $debug ]); \/\/ Add extensions if ($container-&gt;has(RouterInterface::class)) { $environment-&gt;addExtension(new TwigExtension( $container-&gt;get(RouterInterface::class), $config['twig']['assets_url'], $config['twig']['assets_version'] )); } if ($debug) { $environment-&gt;addExtension(new TwigExtensionDebug()); } \/\/ Add user defined extensions $this-&gt;injectExtensions($environment, $container, $config['twig']['extensions']); \/\/ Inject environment $twig = new TwigRenderer($environment, $config['templates']['extension']); \/\/ Add template paths foreach ($config['templates']['paths'] as $namespace =&gt; $paths) { $namespace = is_numeric($namespace) ? null : $namespace; foreach ((array) $paths as $path) { $twig-&gt;addPath($path, $namespace); } } return $twig; } \/** * Inject extensions into the TwigEnvironment instance. * * @param TwigEnvironment $environment * @param ContainerInterface $container * @param array $extensions * @throws Exception\\InvalidExtensionException *\/ private function injectExtensions(TwigEnvironment $environment, ContainerInterface $container, array $extensions) { foreach ($extensions as $extension) { \/\/ Load the extension from the container if (is_string($extension) &amp;&amp; $container-&gt;has($extension)) { $extension = $container-&gt;get($extension); } if (! $extension instanceof Twig_ExtensionInterface) { throw new Exception\\InvalidExtensionException(sprintf( 'Twig extension must be an instance of Twig_ExtensionInterface; \"%s\" given,', is_object($extension) ? get_class($extension) : gettype($extension) )); } if ($environment-&gt;hasExtension($extension-&gt;getName())) { continue; } $environment-&gt;addExtension($extension); } } \/\/ The mergeConfig function is not needed anymore \/\/ private function mergeConfig($config) } "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/contributing.html#3-1","title":"3.1. Contributing","content":"Visit github.com\/sandrokeil\/interop-config\/ for the project website. Make sure you have execute composer install Be sure you are in the root directory "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/contributing.html#3-1-1","title":"3.1.1. Resources","content":"If you wish to contribute to interop-config, please be sure to read to the following resources: Coding Standards: PSR-0\/1\/2\/4 Git Guide: README-GIT.md If you are working on new features, or refactoring an existing component, please create an issue first, so we can discuss it."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/contributing.html#3-1-2","title":"3.1.2. Running tests","content":"To run tests execute phpunit:$ .\/vendor\/bin\/phpunit You can turn on conditional tests with the TestConfig.php file. To do so: Enter the test\/ subdirectory. Copy TestConfig.php.dist file to TestConfig.php Edit TestConfig.php to enable any specific functionality you want to test, as well as to provide test values to utilize. "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/contributing.html#3-1-3","title":"3.1.3. Running PHPCodeSniffer","content":"To check coding standards execute phpcs:$ .\/vendor\/bin\/phpcs To auto fix coding standard issues execute:$ .\/vendor\/bin\/phpcbf "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/contributing.html#3-1-4","title":"3.1.4. Running benchmarks","content":"To run benchmarks execute phpbench:$ .\/vendor\/bin\/phpbench run --report=aggregate "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/contributing.html#3-1-5","title":"3.1.5. Generate documentation","content":"To generate the documentation execute bookdown:$ .\/vendor\/bin\/bookdown doc\/bookdown.json "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/contributing.html#3-1-6","title":"3.1.6. Composer shortcuts","content":"For every program above there are shortcuts defined in the composer.json file. check: Executes PHPCodeSniffer and PHPUnit cs: Executes PHPCodeSniffer cs-fix: Executes PHPCodeSniffer and auto fixes issues test: Executes PHPUnit test-coverage: Executes PHPUnit with code coverage docs: Generates awesome Bookdown.io docs benchmark: Executes PHPBench "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/readme-git.html#3-2-1","title":"3.2.1. Setup your own public GitHub repository","content":"Your first step is to establish a public repository from which you can pull your work into the master repository. Setup a GitHub account, if you haven't yet Fork the interop-config repository Clone your fork locally and enter it (use your own GitHub username in the statement below) $ git clone git@github.com:[your username]\/interop-config.git $ cd interop-config Add a remote to the canonical interop-config repository, so you can keep your fork up-to-date: $ git remote add upstream https:\/\/github.com\/sandrokeil\/interop-config.git $ git fetch upstream "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/readme-git.html#3-2-2","title":"3.2.2. Keeping Up-to-Date","content":"Periodically, you should update your fork to match the canonical interop-config repository. we have added a remote to the interop-config repository, which allows you to do the following:$ git checkout master $ git pull upstream master - OPTIONALLY, to keep your remote up-to-date - $ git push origin If you're tracking other branches -- for example, the develop branch, where new feature development occurs -- you'll want to do the same operations for that branch; simply substitute \"develop\" for \"master\"."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/readme-git.html#3-2-3","title":"3.2.3. Working on interop-config","content":"When working on interop-config, we recommend you do each new feature or bugfix in a new branch. This simplifies the task of code review as well as of merging your changes into the canonical repository.A typical work flow will then consist of the following: Create a new local branch based off your master branch. Switch to your new local branch. (This step can be combined with the previous step with the use of git checkout -b.) Do some work, commit, repeat as necessary. Push the local branch to your remote repository. Send a pull request. The mechanics of this process are actually quite trivial. Below, we will create a branch for fixing an issue in the tracker.$ git checkout -b 3452 Switched to a new branch '3452' ... do some work ...$ git commit ... write your log message ...$ git push origin HEAD:3452 Counting objects: 38, done. Delta compression using up to 2 threads. Compression objects: 100$ (18\/18), done. Writing objects: 100$ (20\/20), 8.19KiB, done. Total 20 (delta 12), reused 0 (delta 0) To ssh:\/\/git@github.com\/sandrokeil\/interop-config.git g5342..9k3532 HEAD -&gt; master You can do the pull request from GitHub. Navigate to your repository, select the branch you just created, and then select the \"Pull Request\" button in the upper right. Select the user sandrokeil as the recipient."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/readme-git.html#3-2-3-1","title":"3.2.3.1. Branch to issue the pull request","content":"Which branch should you issue a pull request against? For fixes against the stable release, issue the pull request against the master branch. For new features, or fixes that introduce new elements to the public API (such as new public methods or properties), issue the pull request against the develop branch. "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/readme-git.html#3-2-4","title":"3.2.4. Branch Cleanup","content":"As you might imagine, if you are a frequent contributor, you'll start to get a ton of branches both locally and on your remote.Once you know that your changes have been accepted to the master repository, we suggest doing some cleanup of these branches. Local branch cleanup $ git branch -d &lt;branchname&gt; Remote branch removal $ git push origin :&lt;branchname&gt; "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/readme-git.html#3-2-5","title":"3.2.5. Feed and emails","content":"RSS feeds may be found at:https:\/\/github.com\/sandrokeil\/interop-config\/commits\/&lt;branch&gt;.atomwhere &lt;branch&gt; is a branch in the repository.To subscribe to git email notifications, simply watch or fork the interop-config repository on GitHub."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3","title":"3.3. Changelog","content":"All notable changes to this project will be documented in this file, in reverse chronological order by release."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-1","title":"3.3.1. 1.0.0 (2015-03-05)","content":" This release contains BC breaks, but upgrade path is simple. "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-1-1","title":"3.3.1.1. Added","content":" #26: dimensions() method to RequiresConfig to make configuration depth flexible "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-1-2","title":"3.3.1.2. Deprecated","content":" Nothing "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-1-3","title":"3.3.1.3. Removed","content":" #26: vendorName() and packageName() method from RequiresConfig, replaced by dimensions() method It's recommended to remove the methods and use the values directly in dimensions() to increase performance public function dimensions() { return [$this-&gt;vendorName(), $this-&gt;packageName()]; } #26: RequiresContainerId interface is renamed to RequiresConfigId use the container id as a second argument by options() method. "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-1-4","title":"3.3.1.4. Fixed","content":" #28: Throws exception if dimensions are set but default options are available and no mandatory options configured "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-2-1","title":"3.3.2.1. Added","content":" Nothing "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-2-2","title":"3.3.2.2. Deprecated","content":" Nothing "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-2-3","title":"3.3.2.3. Removed","content":" Nothing "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-2-4","title":"3.3.2.4. Fixed","content":" Fixed Illegal offset type in isset or empty if options are empty and recursive mandatory options are used "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-3-1","title":"3.3.3.1. Added","content":" #9: Introducing ProvidesDefaultOptions interface #13: Support for recursive mandatory options check canRetrieveOptions() to ConfigurationTrait to perform the options check without throwing an exception optionsWithFallback() to ConfigurationTrait which uses default options if config can not be retrieved OptionNotFoundException and MandatoryOptionNotFoundException extends OutOfBoundsException instead of RuntimeException Check if retrieved options are an array or an instance of ArrayAccess Benchmark suite Updated documentation "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-3-2","title":"3.3.3.2. Deprecated","content":" Nothing "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-3-3","title":"3.3.3.3. Removed","content":" HasConfig interface, was renamed to RequiresConfig HasContainer interface, was renamed to RequiresContainerId HasMandatoryOptions interface, was renamed to RequiresMandatoryOptions HasDefaultOptions interface, was renamed to ProvidesDefaultOptions ObtainsOptions interface, was merged in RequiresConfig OptionalOptions interface, can be achieved via ProvidesDefaultOptions "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-3-4","title":"3.3.3.4. Fixed","content":" fixed wrong function name in documentation "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-4-1","title":"3.3.4.1. Added","content":" #5: replaced componentName function with packageName (PSR-4 standard) "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-4-2","title":"3.3.4.2. Deprecated","content":" Nothing "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-4-3","title":"3.3.4.3. Removed","content":" #5: componentName function from HasConfig interface (BC break) "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-4-4","title":"3.3.4.4. Fixed","content":" Nothing "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-5-1","title":"3.3.5.1. Added","content":" Initial release Added interfaces #2: Added trait implementation "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-5-2","title":"3.3.5.2. Deprecated","content":" Nothing "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-5-3","title":"3.3.5.3. Removed","content":" Nothing "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-5-4","title":"3.3.5.4. Fixed","content":" Nothing "}]