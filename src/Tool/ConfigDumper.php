<?php
/**
 * Sandro Keil (https://sandro-keil.de)
 *
 * @link      http://github.com/sandrokeil/interop-config for the canonical source repository
 * @copyright Copyright (c) 2017-2017 Sandro Keil
 * @license   http://github.com/sandrokeil/interop-config/blob/master/LICENSE.md New BSD License
 */

declare(strict_types=1);

namespace Interop\Config\Tool;

use Interop\Config\Exception\InvalidArgumentException;
use Interop\Config\ProvidesDefaultOptions;
use Interop\Config\RequiresConfig;
use Interop\Config\RequiresConfigId;
use Interop\Config\RequiresMandatoryOptions;
use Traversable;

/**
 * Dumps configuration based on factory definition
 *
 * @copyright Copyright (c) 2016 Zend Technologies USA Inc. (http://www.zend.com)
 */
class ConfigDumper
{
    const CONFIG_TEMPLATE = <<<EOC
<?php
/**
 * This file generated by %s.
 * Generated %s
 */

return %s;
EOC;

    /**
     * @var ConsoleHelper
     */
    private $helper;

    public function __construct(ConsoleHelper $helper = null)
    {
        $this->helper = $helper ?: new ConsoleHelper();
    }

    /**
     * @param array $config
     * @param string $className
     * @return array
     * @throws InvalidArgumentException for invalid $className
     */
    public function createDependencyConfig(array $config, $className)
    {
        $this->validateClassName($className);

        $reflectionClass = new \ReflectionClass($className);

        // class is an interface; do nothing
        if ($reflectionClass->isInterface()) {
            return $config;
        }

        $interfaces = $reflectionClass->getInterfaceNames();

        if (in_array(RequiresConfigId::class, $interfaces, true)) {
            $configId = $this->helper->readLine('config id (name)');
        }

        $factory = $reflectionClass->newInstanceWithoutConstructor();
        $dimensions = [];
        $mandatoryOptions = [];
        $defaultOptions = [];

        if (in_array(RequiresConfig::class, $interfaces, true)) {
            $dimensions = $factory->dimensions();
        }

        if (in_array(RequiresMandatoryOptions::class, $interfaces, true)) {
            $mandatoryOptions = $this->readMandatoryOption($factory->mandatoryOptions());
        }

        if (in_array(ProvidesDefaultOptions::class, $interfaces)) {
            $defaultOptions = $factory->defaultOptions();
        }

        $options = array_replace_recursive(
            $defaultOptions instanceof \Iterator ? iterator_to_array($defaultOptions) : (array)$defaultOptions,
            (array)$mandatoryOptions
        );

        $dimensions[] = $configId;

        $parent = &$config;

        foreach ($dimensions as $dimension) {
            if (empty($parent[$dimension])) {
                $parent[$dimension] = [];
            }
            $parent = &$parent[$dimension];
        }

        $parent = $options;

        return $config;
    }

    private function readMandatoryOption(iterable $mandatoryOptions, $path = ''): array
    {
        $options = [];

        foreach ($mandatoryOptions as $key => $mandatoryOption) {
            if (!is_scalar($mandatoryOption)) {
                $options[$key] = $this->readMandatoryOption($mandatoryOptions[$key], trim($path . '.' . $key, '.'));
                continue;
            }
            $options[$mandatoryOption] = $this->helper->readLine(trim($path . '.' . $mandatoryOption, '.'));
        }
        return $options;
    }

    /**
     * @throws InvalidArgumentException if class name is not a string or does not exist.
     */
    private function validateClassName(string $className): void
    {
        if (!is_string($className)) {
            throw new InvalidArgumentException(
                sprintf('Class name must be a string, %s given', gettype($className))
            );
        }

        if (!class_exists($className)) {
            throw new InvalidArgumentException(sprintf('Cannot find class with name "%s".', $className));
        }
    }

    public function dumpConfigFile(iterable $config): string
    {
        return sprintf(
            self::CONFIG_TEMPLATE,
            get_class($this),
            date('Y-m-d H:i:s'),
            $this->prepareConfig($config)
        );
    }

    private function prepareConfig(iterable $config, int $indentLevel = 1): string
    {
        $indent = str_repeat(' ', $indentLevel * 4);
        $entries = [];

        foreach ($config as $key => $value) {
            $key = $this->createConfigKey($key);
            $entries[] = sprintf(
                '%s%s%s,',
                $indent,
                $key ? sprintf('%s => ', $key) : '',
                $this->createConfigValue($value, $indentLevel)
            );
        }

        $outerIndent = str_repeat(' ', ($indentLevel - 1) * 4);

        return sprintf(
            "[\n%s\n%s]",
            implode("\n", $entries),
            $outerIndent
        );
    }

    private function createConfigKey($key): string
    {
        return sprintf("'%s'", $key);
    }

    private function createConfigValue($value, int $indentLevel): string
    {
        if (is_array($value) || $value instanceof Traversable) {
            return $this->prepareConfig($value, $indentLevel + 1);
        }

        if (is_string($value) && class_exists($value)) {
            return sprintf('\\%s::class', ltrim($value, '\\'));
        }

        return var_export($value, true);
    }
}
