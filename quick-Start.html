<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
    <meta name="HandheldFriendly" content="True"/>
    <title>Quick Start</title>
    <link rel="stylesheet"
          href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.5/cerulean/bootstrap.min.css">
    <link rel="stylesheet"
          href="http://tobiju.github.io/share/prismjs/prism-ghcolors.css"/>
    <link rel="stylesheet"
          href="http://tobiju.github.io/share/prismjs/prism-linenumbers.css"/>

    <style>
        body, html {
            height: 100%;
        }

        .page-wrapper {
            min-height: 100%;
            padding-bottom: 204px;
            position: relative;
        }

        /* Header Section */
        header {
            background: white;
            color: black;
            font-weight: 300;
        }

        /* Content Section */
        #content {
            margin-bottom: 17px;
            font-size: 17px;
            min-height: 200px;
        }

        .links {
            background: #f8f8f8;
            border-top: 1px solid #e5e5e5;
            border-bottom: 1px solid #e5e5e5;
            padding: 16px 0;
        }

        .links .prev {
            text-align: left;
        }

        .links .parent {
            text-align: center;
        }

        .links .next {
            text-align: right;
        }


        /* Footer Section */
        footer {
            color: black;
            background: white;
            width: 100%;
            position: absolute;
            bottom: 0;
        }

        footer #copyright {
            padding: 30px;
            text-align: center;
            color: #444;
        }

        footer #copyright p {
            margin: 0;
        }

        footer #copyright span a {
            color: white;
        }

        /* Overide bootsstrap default style */
        table, .table {
            font-size: inherit;
        }
    </style>

</head>
    <body>
    <div class="page-wrapper">
        
<header>
    <div class="container">
        <h3 class="title text-center">
            3. Quick Start        </h3>
    </div>
    <div class="links">
        <div class="container">
            <div class="row hidden-sm hidden-md hidden-lg">
    <div class="prev col-xs-6">
                    <p>Prev</p>
            <a href="http://sandrokeil.github.io/interop-config/overview.html">2. interop-config: Overview</a>            </div>
    <div class="next col-xs-6">
                    <p>Next</p>
            <a href="http://sandrokeil.github.io/interop-config/examples.html">4. Examples</a>            </div>
</div>

<div class="row hidden-xs">
    <div class="prev col-sm-4">
                    <p>Prev</p>
            <a href="http://sandrokeil.github.io/interop-config/overview.html">2. interop-config: Overview</a>            </div>
    <div class="parent col-sm-4">
                    <p>Up</p>
            <a href="http://sandrokeil.github.io/interop-config/">interop-config: Create instances depending on configuration</a>            </div>
    <div class="next col-sm-4">
                    <p>Next</p>
            <a href="http://sandrokeil.github.io/interop-config/examples.html">4. Examples</a>            </div>
</div>

        </div>
    </div>
</header>

<section id="content">
    <div class="container">
        <div class="row">
            <div class="col-md-12">

<h1 id="3">3. Quick Start</h1>
<p>Typically you will have a factory which creates a concrete instance depending on some options (dependencies).</p>
<h2 id="3.1">3.1. <code>RequiresConfig</code> interface</h2>
<p>Let's say <em>My factory requires a configuration</em> so you will implement the <code>RequiresConfig</code> interface.</p>
<pre><code class="language-php">use Interop\Config\RequiresConfig;

class MyAwesomeFactory implements RequiresConfig
{
    public function vendorName()
    {
        return 'myvendor';
    }
    
    public function packageName()
    {
        return 'mypackage';
    }
        
    public function canRetrieveOptions($config)
    {
        // custom implementation depending on specifications
    }
    
    public function options($config)
    {
        // custom implementation depending on specifications
    }
}
</code></pre>
<h2 id="3.2">3.2. <code>RequiresContainerId</code> interface</h2>
<p>If you support more than one instance with different configuration then you can say
<em>My factory requires a configuration and requires a container id.</em> Then you use the <code>RequiresContainerId</code> interface which also
implements the <code>RequiresConfig</code> interface.</p>
<pre><code class="language-php">use Interop\Config\RequiresContainerId;

class MyAwesomeFactory implements RequiresContainerId
{
    public function vendorName()
    {
        return 'myvendor';
    }
    
    public function packageName()
    {
        return 'mypackage';
    }
    
    public function containerId()
    {
        return 'mycontainerid';
    }
    
    public function canRetrieveOptions($config)
    {
        // custom implementation depending on specifications
    }
    
    public function options($config)
    {
        // custom implementation depending on specifications
    }
}
</code></pre>
<p>Ok you have now a factory which says that the factory supports a configuration and you have a PHP file which contains
the configuration as a PHP array, but how is the configuration used?</p>
<p>Depending on the implemented interfaces above our configuration PHP file looks like that:</p>
<pre><code class="language-php">// interop config example
return [
    // vendor name
    'myvendor' =&gt; [
        // package name
        'mypackage' =&gt; [
            // container id
            'mycontainerid' =&gt; [
                // some options ...
            ],
        ],
    ],
];
</code></pre>
<p>As you can see that you have to implement the functionality of <code>canRetrieveOptions()</code> and <code>options()</code> method. Good news,
this is not necessary. See <code>ConfigurationTrait</code>.</p>
<h2 id="3.3">3.3. <code>ConfigurationTrait</code>
</h2>
<p>The <code>ConfigurationTrait</code> is a concreate implementation of the <code>RequiresConfig</code> interface and has full support of
<code>ProvidesDefaultOptions</code>, <code>RequiresMandatoryOptions</code> and <code>RequiresContainerId</code> interface. It's a <a href="http://php.net/manual/en/language.oop5.traits.php" title="PHP Trait Documentation">PHP Trait</a> so you can extend your factory
from a class.</p>
<p>Your factory looks now like that:</p>
<pre><code class="language-php">use Interop\Config\RequiresContainerId;
use Interop\Config\ConfigurationTrait;

class MyAwesomeFactory implements RequiresContainerId
{
    use ConfigurationTrait;
    
    public function vendorName()
    {
        return 'myvendor';
    }
    
    public function packageName()
    {
        return 'mypackage';
    }
    
    public function containerId()
    {
        return 'mycontainerid';
    }
}
</code></pre>
<p>Now you have all the ingredients to create multiple different instances depending on configuration.</p>
<h2 id="3.4">3.4. Create an instance</h2>
<p>Factories are often implemented as a <a href="http://php.net/manual/en/language.oop5.magic.php#object.invoke" title="PHP __invoke() Documentation">callable</a>.
This means that your factory instance can be called like a function. You can also use a <code>create</code> method or something else.</p>
<p>The factory gets a <code>ContainerInterface</code> (<a href="https://github.com/php-fig/fig-standards/blob/master/proposed/container-meta.md">Container PSR</a>)
provided to retrieve the configuration.</p>
<blockquote>
<p>Note that the configuration above is injected as <code>$config</code> in <code>options()</code></p>
</blockquote>
<pre><code class="language-php">use Interop\Config\RequiresContainerId;
use Interop\Config\ConfigurationTrait;
use Interop\Container\ContainerInterface;

class MyAwesomeFactory implements RequiresContainerId
{
    use ConfigurationTrait;
    
    public function vendorName()
    {
        return 'myvendor';
    }
    
    public function packageName()
    {
        return 'mypackage';
    }
    
    public function containerId()
    {
        return 'mycontainerid';
    }
    
    public function __invoke(ContainerInterface $container)
    {
        // get options for myvendor.mypackage.mycontainerid
        // method options() is implemented in ConfigurationTrait
        $options = $this-&gt;options($container-&gt;get('config'));
        
        return new Awesome($options);
    }
}
</code></pre>
<p>The <code>ConfigurationTrait</code> does the job to check and retrieve options depending on implemented interfaces. <em>Nice, but what is
if I have mandatory options?</em> See <code>RequiresMandatoryOptions</code> interface.</p>
<h2 id="3.5">3.5. <code>RequiresMandatoryOptions</code> interface</h2>
<p>The <code>RequiresMandatoryOptions</code> interface specification says that it MUST support mandatory options check. Let's say that we need
params for a db connection. Our config <em>should</em> looks like that:</p>
<pre><code class="language-php">// interop config example
return [
    // vendor name
    'myvendor' =&gt; [
        // package name
        'mypackage' =&gt; [
            // container id
            'mycontainerid' =&gt; [
                'params' =&gt; [
                    'user'     =&gt; 'username',
                    'password' =&gt; 'password',
                    'dbname'   =&gt; 'database',
                ],
            ],
        ],
    ],
];
</code></pre>
<p>Remember our factory sentence. <em>My factory requires a configuration and requires a container id along with mandatory options.</em>.
The <code>ConfigurationTrait</code> ensures that these options are available, otherwise an exception is thrown. This is great, because
the developer gets an exact exception message with what is wrong. This is useful for developers who use your factory the first time.</p>
<pre><code class="language-php">use Interop\Config\RequiresContainerId;
use Interop\Config\RequiresMandatoryOptions;
use Interop\Config\ConfigurationTrait;
use Interop\Container\ContainerInterface;

class MyAwesomeFactory implements RequiresContainerId, RequiresMandatoryOptions
{
    use ConfigurationTrait;
    
    public function vendorName()
    {
        return 'myvendor';
    }
    
    public function packageName()
    {
        return 'mypackage';
    }
    
    public function containerId()
    {
        return 'mycontainerid';
    }
    
    public function mandatoryOptions()
    {
        return ['params' =&gt; ['user', 'password', 'dbname']];
    }
    
    public function __invoke(ContainerInterface $container)
    {
        // get options for myvendor.mypackage.mycontainerid
        // method options() is implemented in ConfigurationTrait
        // an exception is raised when a mandatory option is missing
        $options = $this-&gt;options($container-&gt;get('config'));
        
        return new Awesome($options);
    }
}
</code></pre>
<p><em>Hey, the database port and host is missing.</em> That's right, but the default value of the port is <em>3306</em> and the host is
<em>localhost</em>. It makes no sense to set it in the configuration. <em>So I make the database port/host not configurable?</em> No, you
use the <code>ProvidesDefaultOptions</code> interface.</p>
<h2 id="3.6">3.6. <code>ProvidesDefaultOptions</code> interface</h2>
<p>The <code>ProvidesDefaultOptions</code> interface defines default options for your instance. These options are merged with the provided
options.</p>
<p>Remember: <em>My factory requires configuration, requires a container id along with mandatory options and it provides default options.</em></p>
<pre><code class="language-php">use Interop\Config\RequiresContainerId;
use Interop\Config\RequiresMandatoryOptions;
use Interop\Config\RequiresDefaultOptions;
use Interop\Config\ConfigurationTrait;
use Interop\Container\ContainerInterface;

class MyAwesomeFactory implements RequiresContainerId, RequiresMandatoryOptions, RequiresDefaultOptions
{
    use ConfigurationTrait;
    
    public function vendorName()
    {
        return 'myvendor';
    }
    
    public function packageName()
    {
        return 'mypackage';
    }
    
    public function containerId()
    {
        return 'mycontainerid';
    }
    
    public function mandatoryOptions()
    {
        return ['params' =&gt; ['user', 'password', 'dbname']];
    }
    
    public function defaultOptions()
    {
        return [
            'params' =&gt; [
                'host' =&gt; 'localhost',
                'port' =&gt; '3306',
            ],
        ];
    }
    
    public function __invoke(ContainerInterface $container)
    {
        // get options for myvendor.mypackage.mycontainerid
        // method options() is implemented in ConfigurationTrait
        // an exception is raised when a mandatory option is missing
        // if host/port is missing, default options will be used
        $options = $this-&gt;options($container-&gt;get('config'));
        
        return new Awesome($options);
    }
}
</code></pre>
<p>Now you have a bullet proof factory class which throws meaningful exceptions if something goes wrong. <em>This is cool, but
I don't want to use exceptions.</em> No problem, see next.</p>
<h2 id="3.7">3.7. Avoid exceptions</h2>
<p>The <code>RequiresConfig</code> interface provides a method <code>canRetrieveOptions()</code>. This method checks if options are available depending on
implemented interfaces and checks that the retrieved options are an array or have implemented <code>\ArrayAccess</code>.</p>
<p>You can call this function and if it returns false, you can use the default options.</p>
<pre><code class="language-php">use Interop\Config\RequiresContainerId;
use Interop\Config\RequiresMandatoryOptions;
use Interop\Config\RequiresDefaultOptions;
use Interop\Config\ConfigurationTrait;
use Interop\Container\ContainerInterface;

class MyAwesomeFactory implements RequiresContainerId, RequiresMandatoryOptions, ProvidesDefaultOptions
{
    use ConfigurationTrait;
    
    // other functions see above
    
    public function __invoke(ContainerInterface $container)
    {
        $config = $container-&gt;get('config')
        
        $options = [];
        
        if ($this-&gt;canRetrieveOptions($config)) {
            // get options for myvendor.mypackage.mycontainerid
            // method options() is implemented in ConfigurationTrait
            // if host/port is missing, default options will be used
            $options = $this-&gt;options($config);
        } elseif ($this instanceof RequiresDefaultOptions) {
            $options = $this-&gt;defaultOptions();
        }
        
        return new Awesome($options);
    }
}
</code></pre>
<p><em>Nice, is there a one-liner?</em> Of course. You can use the <code>optionsWithFallback()</code> method. This function is not a part
of the specification but is implemented in <code>ConfigurationTrait</code> to reduce some boilerplate code.</p>
<pre><code class="language-php">use Interop\Config\RequiresContainerId;
use Interop\Config\RequiresMandatoryOptions;
use Interop\Config\RequiresDefaultOptions;
use Interop\Config\ConfigurationTrait;
use Interop\Container\ContainerInterface;

class MyAwesomeFactory implements RequiresContainerId, RequiresMandatoryOptions, ProvidesDefaultOptions
{
    use ConfigurationTrait;
    
    // other functions see above
    
    public function __invoke(ContainerInterface $container)
    {
        // get options for myvendor.mypackage.mycontainerid
        // method options() is implemented in ConfigurationTrait
        // if configuration is not available, default options will be used
        $options = $this-&gt;optionsWithFallback($container-&gt;get('config'));
        
        return new Awesome($options);
    }
}
</code></pre>
<p><em>Using <code>optionsWithFallback()</code> method and the <code>RequiresMandatoryOptions</code> is ambiguous or?</em> Yes, so it's up to you to implement
the interfaces in a sense order.</p>

</div>
</div>
</div>
</section>

<footer>
    <div class="links">
        <div class="container">
            <div class="row hidden-sm hidden-md hidden-lg">
    <div class="prev col-xs-6">
                    <p>Prev</p>
            <a href="http://sandrokeil.github.io/interop-config/overview.html">2. interop-config: Overview</a>            </div>
    <div class="next col-xs-6">
                    <p>Next</p>
            <a href="http://sandrokeil.github.io/interop-config/examples.html">4. Examples</a>            </div>
</div>

<div class="row hidden-xs">
    <div class="prev col-sm-4">
                    <p>Prev</p>
            <a href="http://sandrokeil.github.io/interop-config/overview.html">2. interop-config: Overview</a>            </div>
    <div class="parent col-sm-4">
                    <p>Up</p>
            <a href="http://sandrokeil.github.io/interop-config/">interop-config: Create instances depending on configuration</a>            </div>
    <div class="next col-sm-4">
                    <p>Next</p>
            <a href="http://sandrokeil.github.io/interop-config/examples.html">4. Examples</a>            </div>
</div>

        </div>
    </div>
    <div id="copyright">
        <div class="container">
            <div class="row">
                <div class="col-md-12">
                    <p>
                        Powered by <a href="https://github.com/tobiju/bookdown-bootswatch-templates" title="Visit project to generate your own docs">Bookdown Bootswatch Templates</a>.
                    </p>
                </div>
            </div>
        </div>
    </div>
</footer>
    </div>

    <script src="http://tobiju.github.io/share/prismjs/main.js"></script>
    <script src="http://tobiju.github.io/share/prismjs/prism.js"></script>
</body>
</html>
